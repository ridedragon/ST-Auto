# MVU 脚本生命周期与重建机制分析

## 1. 问题描述
`auto-run` 脚本无法在 MVU 脚本重建时（如切换角色卡、创建新聊天）同步重建。

## 2. 核心发现
通过分析 MVU 源码，特别是 `main.ts` 和 `panel.ts`，得出以下结论：
- MVU 脚本本身没有复杂的内部重建逻辑。
- 其能在切换角色后重新加载，是因为 Tavern Helper 会完全 **销毁并重新执行** 整个脚本的 iframe。
- `[MVU]脚本加载成功` 的 `toastr` 通知，是其初始化流程的最后一步。
- 在显示通知之前，`exportGlobals()` 函数会创建一个新的 `Mvu` 对象实例，并将其挂载到 `window.parent.Mvu` 上。

## 3. 之前方案失败的根本原因
我之前的所有方案（DOM 监听、事件监听、简单的实例轮询）都失败了，根本原因在于 **`auto-run` 脚本的 iframe 同样被销毁和重建了**。

这导致：
- **状态丢失**：在 `auto-run` 脚本内部用 `let` 或 `const` 定义的任何变量（如 `lastSeenMvuInstance` 或 `setInterval` 的 ID）都会在 iframe 销毁时丢失。
- **错误的初始状态**：当 `auto-run` 的新 iframe 被创建时，它内部的 `lastSeenMvuInstance` 变量会被重新初始化。它会获取 **当前** 的 `window.parent.Mvu` 实例作为它的“初始值”。此时，MVU 可能已经完成了重建，所以 `auto-run` 看到的是一个“新”的实例，但它却认为这是“旧”的实例，导致 `currentMvu !== lastSeenMvuInstance` 的比较永远为 `false`。

## 4. 最终解决方案的逻辑（已更新）
之前所有方案都失败了，证明我对状态持久性的假设是错误的。`window.parent` 上的自定义属性可能在 Tavern Helper 的某些操作下被清除。

为了解决状态丢失的问题，必须使用一个 **最持久的客户端存储** 来记录 MVU 实例的状态。在浏览器环境中，这就是 `localStorage`。

最终方案步骤：
1.  **使用 `localStorage`**：我们将使用 `localStorage` 来存储上一个已处理的 MVU 实例的唯一标识符。
2.  **动态附加唯一 ID**：由于不能直接序列化和比较对象实例，我们将采用“标记”策略。当 `auto-run` 脚本第一次遇到一个新的、未被标记的 `Mvu` 实例时，它会动态地给这个对象附加一个唯一的属性，例如 `window.parent.Mvu.__auto_run_instance_id = Math.random()`。
3.  **存储和比较 ID**:
    a. 在 `auto-run` 脚本加载时，从 `localStorage.getItem('__auto_run_last_seen_mvu_id')` 读取上一次保存的 ID。
    b. 使用 `setInterval` 定期轮询，检查 `window.parent.Mvu` 对象。
    c. 如果 `window.parent.Mvu` 存在，但它**没有** `__auto_run_instance_id` 属性，这**明确**地表明这是一个全新的、我们从未处理过的 MVU 实例。
    d. 此时，触发 `auto-run` 自身的 `rebuild()` 逻辑。
    e. **关键一步**：在重建逻辑执行后，立即给这个新的 MVU 实例打上标记：创建一个新的唯一 ID，将其附加到 `window.parent.Mvu.__auto_run_instance_id` 上，并将这个新 ID 保存到 `localStorage` 中。
4.  **处理已标记实例**：如果轮询时发现 `window.parent.Mvu` 存在且**拥有** `__auto_run_instance_id` 属性，我们会将其 ID 与 `localStorage` 中存储的 ID 进行比较。如果 ID 不匹配，同样说明 MVU 发生了重建，执行与步骤 3.d 和 3.e 相同的操作。

这个方案利用了 `localStorage` 的终极持久性和动态附加属性的“标记”能力，创建了一个能够跨越页面刷新、iframe 重建等所有场景的、绝对可靠的“已处理”状态，从而精确地捕捉到 MVU 的每一次新生。
