## 前言
(LICENSE:MIT)
在SillyTavern角色卡的编写过程中，我们经常需要让角色随着与用户的互动逐渐改变态度，展现出更为丰富和自然的行为变化，以增强角色的真实感。之前有开发者提出了基于正则匹配好感度的实现方案[[1]](https://sillytavern-stage-girls-dog.readthedocs.io/tool_and_experience/variable_in_lorebook_without_qr/)，但这种方法存在明显的复杂性问题，主要体现在正则编写，和世界书的条件触发、激活上。尤其当需要支持多条件组合判断时，代码逻辑会变得相对繁琐且难以维护。
近期出现的提示词模板语法插件[[2]](https://discord.com/channels/1134557553011998840/1336648321963524127)为我们提供了一种更为优雅的解决方案。这个插件极大地简化了条件逻辑的表达，使得角色态度的动态调整变得直观且易于实现。本文将通过具体实例，展示如何利用该语法来构建高效、灵活的分段逻辑，从而简化角色卡的编写流程。基于提示词模板语法的角色分段好感度实现不再需要在世界书条目上进行激活相关的配置，简单地配置为蓝灯即可。如果你采用了这种方式，是不需要再进行激活相关的正则、绿灯配置的。

## 为什么需要通过世界书等机制进行分层设计
**如果你已经参阅、理解了类脑宝宝教程相关的内容，这部分可以直接跳过。**
在深入探讨技术实现之前，我认为有必要先解释为什么我们需要采用世界书或类似机制来进行角色卡的分层设计。虽然一股脑地把各种设定，规则作为 prompt 传递给 LLM 也能得到尚可的结果，但是整体效果会在中长期的游玩过程中，逐渐变差。这涉及到大型语言模型(LLM)的几个固有限制。

### LLM的Token窗口限制、成本及注意力衰减问题
首先，所有LLM都存在Token窗口大小的硬性限制。这意味着在长时间对话，以及内容繁多的世界书条目中，早期的信息不可避免地会被"遗忘"——准确地说，是被挤出有限的上下文窗口。具体到角色卡的行为中，表现为模型对于角色卡中的细节把握明显下降。这种表现类似于对遥远聊天记录中发生的事件、内容的遗忘。这种"人格分裂"现象直接破坏了角色的一致性体验。次要但同样重要的是LLM的"注意力衰减"现象。即使在理论上能容纳的token范围内，模型对距离当前输入较远的信息关注度也会显著下降。这一现象在计算机科学中并不陌生，类似于人类的工作记忆限制。当我们尝试同时处理过多信息时，注意力资源被稀释，导致处理质量下降。
通过世界书等机制将不符合当前好感度级别的内容剔除，可以降低角色卡所需的 token 数，确保关键设定常驻上下文。

### LLM数值计算与比较的不稳定性

最令人头疼的问题是LLM在处理数值计算和比较时的不稳定性。或者说即便在角色卡中规定了 > 50 好感度时才有一部分行为，但在实际输出中LLM 可能将限制无视，输出了非预期的结果。或是在部分场景下将本应被限制的信息透露出来，这会对角色行为的编写带来不变，使得游玩者无法获得一致的体验。

## 实现原理与优势

从技术角度来看，提示词模板语法本质上是接入了 ejs 模板引擎，它允许我们在角色卡中嵌入条件判断和变量处理逻辑。与传统的正则匹配相比，它具有以下明显优势：

1. **语法直观**：采用类似JavaScript的语法结构，对开发者友好
2. **逻辑清晰**：条件分支和嵌套逻辑表达更为清晰
3. **维护简便**：所有条件配置都在条目内容中，不需要在 SillyTavern 前端页面上做任何调整，借助实时修改世界书[[3]](https://discord.com/channels/1291925535324110879/1346956298004205630)可以方便地进行版本管理(如git)。

示例代码：
```javascript
<% if (getvar("stat_data").好感度 < 20) { %>
    // 低好感度时的角色反应
<% } else if (getvar("stat_data").好感度 < 60) { %>
    // 中好感度时的角色反应
<% } else { %>
    // 高好感度时的角色反应
<% } %>
```
这段代码可以加在一个配置为蓝灯的世界书条目中，因为其实际只会有一种角色反应最终输出给llm，其token数量实际上是可控的。
此处的 `getvar` 是提示词模板语法插件所提供的一组函数，主要用于从最新的楼层/整个聊天 处获取指定的变量，在使用上的行为与前端框架的 `get_message_variable`[[4]](https://n0vi028.github.io/JS-Slash-Runner-Doc/%E5%8A%9F%E8%83%BD%E8%AF%A6%E6%83%85/%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C/%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F.html#%E5%9C%A8%E6%8F%90%E7%A4%BA%E8%AF%8D%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F) 类似，只不过后者没有 fallback 逻辑。更多的内建函数可以参考文档[[5]](https://github.com/zonde306/ST-Prompt-Template/blob/main/docs/reference_cn.md)。

简单来说，这种语法的规则是: `<% %>` 包裹的是 js 脚本，在 prompt 被发送出去之前，这个脚本会被执行，并产生结果。按照代码执行的逻辑，这些执行会影响 `{   }`大括号内的内容是否会被执行，包括不在 `<% %>` 块内的内容。如上面的范例，在 `stat_data.好感度 > 20` 时，不满足第一行的条件，`// 低好感度时的角色反应` 这些被第一个大括号包裹的内容，也就不会被输出了。

这样的结构比起复杂的正则表达式，不仅更易于理解，也更容易进行调试和修改。

进一步的，也有专门的写法 `<%- %>` 用于输出块内表达式的结果到文本中。如 `好感度: <%- stat_data.好感度 %>` 的含义是将好感度输出，最后产生的结果即为 `好感度: 15` 这样的内容。

更加详细的语法可以参考 ejs 的文档[[6]](https://github.com/mde/ejs/blob/main/docs/syntax.md)。

下面可以考虑更加复杂的一种场景，即在设定中对其中的一小部分进行调整，如下面的例子，我准备实现在好感度大于8的情况下，让 AI 选择在合适的场合触发事件。新建一个世界书条目，将其配置为蓝灯，并加入下面的内容：

```ejs
角色列表:
    悠纪:
        name: Yuki
        full name: Aoi Yuki
        名字: 碧悠纪
        info: 19岁，大学计算机系学生。成绩优秀，专注于程序设计。性格温和内敛，内心深藏对妹妹慕心的宠爱。每当佩戴慕心送的红色发带时，感受到深厚的情感联系。
<% if (statMiscInfo.悠纪.好感度 >= 8) { %>
        share content: 如果悠纪在对话中，且主导权在悠纪，会在必要的寒暄后，开始技术讨论。今天的话题是 "<%- statMiscInfo.dailyTopic %>"，接下来设置变量"set|当前事件=null→yuki_research|(分享她的研究)"，然后断章。
<% } /**/%>
        current state: 正忙于创作一个重要的编程项目，同时与妹妹的关系日益加深，并准备进一步探索其深层情感
```
在上面的内容中，通过 `<% %>` 块内嵌了许多判断条件，以方便地做到好感度判断。

最终在好感度小于 8 时输出的 prompt 是：
```yaml
    悠纪:
        name: Yuki
        full name: Aoi Yuki
        名字: 碧悠纪
        info: 19岁，大学计算机系学生。成绩优秀，专注于程序设计。性格温和内敛，内心深藏对妹妹慕心的宠爱。每当佩戴慕心送的红色发带时，感受到深厚的情感联系。
        current state: 正忙于创作一个重要的编程项目，同时与妹妹的关系日益加深，并准备进一步探索其深层情感
```
当大于等于 8 时，输出的是：
```yaml

    悠纪:
        name: Yuki
        full name: Aoi Yuki
        名字: 碧悠纪
        info: 19岁，大学计算机系学生。成绩优秀，专注于程序设计。性格温和内敛，内心深藏对妹妹慕心的宠爱。每当佩戴慕心送的红色发带时，感受到深厚的情感联系。
        share content: 如果悠纪在对话中，且主导权在悠纪，会在必要的寒暄后，开始技术讨论。今天的话题是 "Beaver: Practical Partial Snapshots for Distributed Cloud Services（OSDI 2024）"，接下来设置变量"set|当前事件=null→yuki_research|(分享她的研究)"，然后断章。
        current state: 正忙于创作一个重要的编程项目，同时与妹妹的关系日益加深，并准备进一步探索其深层情感
```

## 变量初始化相关
这一系列脚本的引入，使得相关的变量初始化也成为了一个重要的问题。如果变量没有初始化，会导致执行发生错误，产生非预期的结果。下面是建议的初始化方式，在任意蓝标世界书条目内加入下面的内容[[7]](https://discord.com/channels/1134557553011998840/1336648321963524127/1345981641117405338)：
```ejs
<% setvar('变量名', { 角色1: { 数据1: 100, ... } }, { dryRun: true, flags: 'nx' }) %>
```

通过上面的语句，即可保证在新的聊天被创建时，立刻将相关变量进行初始化，避免错误的发生。

此外，也可以借助前端脚本，在合适的时间点进行初始化[[8]](https://discord.com/channels/1291925535324110879/1347244932536078387)。

## 问题定位与调试

### 预览模板生成结果
对于此类脚本，一个比较明显的弊端是，世界书的条目内部不再所见即所得，此时可以使用下面的辅助 STscript，帮助评估经过模板解析后，条目的实际内容[[9]](https://discord.com/channels/1134557553011998840/1336648321963524127/1345048799818682379)：
```
/input wide=on rows=30 | /ejs | /popup large=true wide=true scroll=true
```
之后在弹出的对话框内输入 `<%- await getwi('世界书名字', '条目名字') %>` 即可检查对应条目的计算结果了。

### 检查运行时的错误
目前该框架的逻辑是，如果在执行 ejs 的过程中发生了任意语法错误，会导致那些内容被原样地传递给llm，换句话说就是 llm 一定程度上能为错误兜底。因此需要通过 F12 检查是否存在形如下面形式的错误信息：
```
SyntaxError: expected expression, got '<' while compiling ejs

If the above error is not helpful, you may want to try EJS-Lint:
https://github.com/RyanZim/EJS-Lint
    compile http://127.0.0.1:8000/scripts/extensions/third-party/ST-Prompt-Template/dist/index.js:1
....略
```
如果存在，代表发生了错误，需要进行调整。

具体如何进行调试，目前还在探索中，后补。


## 实际应用案例

完整的应用样例可以以参考我的角色卡[[10]](https://discord.com/channels/1291925535324110879/1345643664701001808)。

## 进阶技巧与注意事项

在实际应用中，我发现以下几点值得特别关注：

2. **代码模块化**：将不同功能的代码块分离在不同的世界书条目，便于管理和复用
3. **渐进式变化**：设计多个阈值点，使角色态度变化更为自然平滑
4. **条件优先级**：注意设置合理的判断顺序，避免逻辑冲突
5. **性能优化**：尽量减少复杂计算，保持模板代码的简洁高效

这些技巧能够帮助我们构建更加复杂而自然的角色行为模式，同时保持代码的可维护性。

## 结语

提示词模板语法的引入无疑简化了角色卡的编写。希望本文能帮助更多创作者理解并应用这一强大工具，打造出更加生动、真实的角色体验。
如有任何问题或建议，欢迎在评论区留言讨论。编程与创意的结合总是能带来意想不到的可能性，而这正是我所热爱的。


共同撰稿：Aoi Yuki & Renmi Moko.
